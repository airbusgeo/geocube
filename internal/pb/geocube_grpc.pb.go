// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package geocube

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GeocubeClient is the client API for Geocube service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GeocubeClient interface {
	// Create one or a list of records
	CreateRecords(ctx context.Context, in *CreateRecordsRequest, opts ...grpc.CallOption) (*CreateRecordsResponse, error)
	// Get records from their ID
	GetRecords(ctx context.Context, in *GetRecordsRequest, opts ...grpc.CallOption) (Geocube_GetRecordsClient, error)
	// List records given criterias
	ListRecords(ctx context.Context, in *ListRecordsRequest, opts ...grpc.CallOption) (Geocube_ListRecordsClient, error)
	// Update records, adding or updating tags
	AddRecordsTags(ctx context.Context, in *AddRecordsTagsRequest, opts ...grpc.CallOption) (*AddRecordsTagsResponse, error)
	// Update records, removing tags
	RemoveRecordsTags(ctx context.Context, in *RemoveRecordsTagsRequest, opts ...grpc.CallOption) (*RemoveRecordsTagsResponse, error)
	// Delete records
	DeleteRecords(ctx context.Context, in *DeleteRecordsRequest, opts ...grpc.CallOption) (*DeleteRecordsResponse, error)
	// Create an AOI if not exists or returns the aoi id of the aoi.
	CreateAOI(ctx context.Context, in *CreateAOIRequest, opts ...grpc.CallOption) (*CreateAOIResponse, error)
	// Get an AOI from its ID
	GetAOI(ctx context.Context, in *GetAOIRequest, opts ...grpc.CallOption) (*GetAOIResponse, error)
	// Create a variable
	CreateVariable(ctx context.Context, in *CreateVariableRequest, opts ...grpc.CallOption) (*CreateVariableResponse, error)
	// Get a variable given its id, name or one of its instance id
	GetVariable(ctx context.Context, in *GetVariableRequest, opts ...grpc.CallOption) (*GetVariableResponse, error)
	// Update some fields of a variable
	UpdateVariable(ctx context.Context, in *UpdateVariableRequest, opts ...grpc.CallOption) (*UpdateVariableResponse, error)
	// Delete a variable iif no dataset has a reference on
	DeleteVariable(ctx context.Context, in *DeleteVariableRequest, opts ...grpc.CallOption) (*DeleteVariableResponse, error)
	// List variables given a name pattern
	ListVariables(ctx context.Context, in *ListVariablesRequest, opts ...grpc.CallOption) (Geocube_ListVariablesClient, error)
	// Instantiate a variable
	InstantiateVariable(ctx context.Context, in *InstantiateVariableRequest, opts ...grpc.CallOption) (*InstantiateVariableResponse, error)
	// Update metadata of an instance
	UpdateInstance(ctx context.Context, in *UpdateInstanceRequest, opts ...grpc.CallOption) (*UpdateInstanceResponse, error)
	// Delete an instance iif no dataset has a reference on
	DeleteInstance(ctx context.Context, in *DeleteInstanceRequest, opts ...grpc.CallOption) (*DeleteInstanceResponse, error)
	// Create or update a palette that can be used to create a display of a dataset
	CreatePalette(ctx context.Context, in *CreatePaletteRequest, opts ...grpc.CallOption) (*CreatePaletteResponse, error)
	// GetInfo on containers
	GetContainers(ctx context.Context, in *GetContainersRequest, opts ...grpc.CallOption) (*GetContainersResponse, error)
	// Index new datasets in the Geocube
	IndexDatasets(ctx context.Context, in *IndexDatasetsRequest, opts ...grpc.CallOption) (*IndexDatasetsResponse, error)
	// Delete datasets using records, instances and/or filepath
	DeleteDatasets(ctx context.Context, in *DeleteDatasetsRequest, opts ...grpc.CallOption) (*DeleteDatasetsResponse, error)
	// Configurate a consolidation process
	ConfigConsolidation(ctx context.Context, in *ConfigConsolidationRequest, opts ...grpc.CallOption) (*ConfigConsolidationResponse, error)
	// Get the configuration of a consolidation
	GetConsolidationParams(ctx context.Context, in *GetConsolidationParamsRequest, opts ...grpc.CallOption) (*GetConsolidationParamsResponse, error)
	// Start a consolidation job
	Consolidate(ctx context.Context, in *ConsolidateRequest, opts ...grpc.CallOption) (*ConsolidateResponse, error)
	// List the jobs given a name pattern
	ListJobs(ctx context.Context, in *ListJobsRequest, opts ...grpc.CallOption) (*ListJobsResponse, error)
	// Get a job given its name
	GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error)
	// Delete jobs given their status
	CleanJobs(ctx context.Context, in *CleanJobsRequest, opts ...grpc.CallOption) (*CleanJobsResponse, error)
	// Retry a job
	RetryJob(ctx context.Context, in *RetryJobRequest, opts ...grpc.CallOption) (*RetryJobResponse, error)
	// Cancel a job
	CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*CancelJobResponse, error)
	// Continue a job that is in waiting state
	ContinueJob(ctx context.Context, in *ContinueJobRequest, opts ...grpc.CallOption) (*ContinueJobResponse, error)
	// Get a cube of data given a CubeParams
	GetCube(ctx context.Context, in *GetCubeRequest, opts ...grpc.CallOption) (Geocube_GetCubeClient, error)
	// Get a XYZTile (can be used with a TileServer, provided a GRPCGateway is up)
	GetXYZTile(ctx context.Context, in *GetTileRequest, opts ...grpc.CallOption) (*GetTileResponse, error)
	// Create a layout to be used for tiling or consolidation
	CreateLayout(ctx context.Context, in *CreateLayoutRequest, opts ...grpc.CallOption) (*CreateLayoutResponse, error)
	// Delete a layout given its name
	DeleteLayout(ctx context.Context, in *DeleteLayoutRequest, opts ...grpc.CallOption) (*DeleteLayoutResponse, error)
	// List layouts given a name pattern
	ListLayouts(ctx context.Context, in *ListLayoutsRequest, opts ...grpc.CallOption) (*ListLayoutsResponse, error)
	// Find all the layouts known for a set of containers
	FindContainerLayouts(ctx context.Context, in *FindContainerLayoutsRequest, opts ...grpc.CallOption) (Geocube_FindContainerLayoutsClient, error)
	// Tile an AOI given a layout
	TileAOI(ctx context.Context, in *TileAOIRequest, opts ...grpc.CallOption) (Geocube_TileAOIClient, error)
	// Create a grid that can be used to tile an AOI
	CreateGrid(ctx context.Context, opts ...grpc.CallOption) (Geocube_CreateGridClient, error)
	// Delete a grid
	DeleteGrid(ctx context.Context, in *DeleteGridRequest, opts ...grpc.CallOption) (*DeleteGridResponse, error)
	// List grids given a name pattern
	ListGrids(ctx context.Context, in *ListGridsRequest, opts ...grpc.CallOption) (*ListGridsResponse, error)
	// Version of the GeocubeServer
	Version(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error)
}

type geocubeClient struct {
	cc grpc.ClientConnInterface
}

func NewGeocubeClient(cc grpc.ClientConnInterface) GeocubeClient {
	return &geocubeClient{cc}
}

func (c *geocubeClient) CreateRecords(ctx context.Context, in *CreateRecordsRequest, opts ...grpc.CallOption) (*CreateRecordsResponse, error) {
	out := new(CreateRecordsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/CreateRecords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) GetRecords(ctx context.Context, in *GetRecordsRequest, opts ...grpc.CallOption) (Geocube_GetRecordsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Geocube_ServiceDesc.Streams[0], "/geocube.Geocube/GetRecords", opts...)
	if err != nil {
		return nil, err
	}
	x := &geocubeGetRecordsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Geocube_GetRecordsClient interface {
	Recv() (*GetRecordsResponseItem, error)
	grpc.ClientStream
}

type geocubeGetRecordsClient struct {
	grpc.ClientStream
}

func (x *geocubeGetRecordsClient) Recv() (*GetRecordsResponseItem, error) {
	m := new(GetRecordsResponseItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geocubeClient) ListRecords(ctx context.Context, in *ListRecordsRequest, opts ...grpc.CallOption) (Geocube_ListRecordsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Geocube_ServiceDesc.Streams[1], "/geocube.Geocube/ListRecords", opts...)
	if err != nil {
		return nil, err
	}
	x := &geocubeListRecordsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Geocube_ListRecordsClient interface {
	Recv() (*ListRecordsResponseItem, error)
	grpc.ClientStream
}

type geocubeListRecordsClient struct {
	grpc.ClientStream
}

func (x *geocubeListRecordsClient) Recv() (*ListRecordsResponseItem, error) {
	m := new(ListRecordsResponseItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geocubeClient) AddRecordsTags(ctx context.Context, in *AddRecordsTagsRequest, opts ...grpc.CallOption) (*AddRecordsTagsResponse, error) {
	out := new(AddRecordsTagsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/AddRecordsTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) RemoveRecordsTags(ctx context.Context, in *RemoveRecordsTagsRequest, opts ...grpc.CallOption) (*RemoveRecordsTagsResponse, error) {
	out := new(RemoveRecordsTagsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/RemoveRecordsTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) DeleteRecords(ctx context.Context, in *DeleteRecordsRequest, opts ...grpc.CallOption) (*DeleteRecordsResponse, error) {
	out := new(DeleteRecordsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/DeleteRecords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) CreateAOI(ctx context.Context, in *CreateAOIRequest, opts ...grpc.CallOption) (*CreateAOIResponse, error) {
	out := new(CreateAOIResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/CreateAOI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) GetAOI(ctx context.Context, in *GetAOIRequest, opts ...grpc.CallOption) (*GetAOIResponse, error) {
	out := new(GetAOIResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/GetAOI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) CreateVariable(ctx context.Context, in *CreateVariableRequest, opts ...grpc.CallOption) (*CreateVariableResponse, error) {
	out := new(CreateVariableResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/CreateVariable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) GetVariable(ctx context.Context, in *GetVariableRequest, opts ...grpc.CallOption) (*GetVariableResponse, error) {
	out := new(GetVariableResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/GetVariable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) UpdateVariable(ctx context.Context, in *UpdateVariableRequest, opts ...grpc.CallOption) (*UpdateVariableResponse, error) {
	out := new(UpdateVariableResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/UpdateVariable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) DeleteVariable(ctx context.Context, in *DeleteVariableRequest, opts ...grpc.CallOption) (*DeleteVariableResponse, error) {
	out := new(DeleteVariableResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/DeleteVariable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) ListVariables(ctx context.Context, in *ListVariablesRequest, opts ...grpc.CallOption) (Geocube_ListVariablesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Geocube_ServiceDesc.Streams[2], "/geocube.Geocube/ListVariables", opts...)
	if err != nil {
		return nil, err
	}
	x := &geocubeListVariablesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Geocube_ListVariablesClient interface {
	Recv() (*ListVariablesResponseItem, error)
	grpc.ClientStream
}

type geocubeListVariablesClient struct {
	grpc.ClientStream
}

func (x *geocubeListVariablesClient) Recv() (*ListVariablesResponseItem, error) {
	m := new(ListVariablesResponseItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geocubeClient) InstantiateVariable(ctx context.Context, in *InstantiateVariableRequest, opts ...grpc.CallOption) (*InstantiateVariableResponse, error) {
	out := new(InstantiateVariableResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/InstantiateVariable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) UpdateInstance(ctx context.Context, in *UpdateInstanceRequest, opts ...grpc.CallOption) (*UpdateInstanceResponse, error) {
	out := new(UpdateInstanceResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/UpdateInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) DeleteInstance(ctx context.Context, in *DeleteInstanceRequest, opts ...grpc.CallOption) (*DeleteInstanceResponse, error) {
	out := new(DeleteInstanceResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/DeleteInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) CreatePalette(ctx context.Context, in *CreatePaletteRequest, opts ...grpc.CallOption) (*CreatePaletteResponse, error) {
	out := new(CreatePaletteResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/CreatePalette", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) GetContainers(ctx context.Context, in *GetContainersRequest, opts ...grpc.CallOption) (*GetContainersResponse, error) {
	out := new(GetContainersResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/GetContainers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) IndexDatasets(ctx context.Context, in *IndexDatasetsRequest, opts ...grpc.CallOption) (*IndexDatasetsResponse, error) {
	out := new(IndexDatasetsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/IndexDatasets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) DeleteDatasets(ctx context.Context, in *DeleteDatasetsRequest, opts ...grpc.CallOption) (*DeleteDatasetsResponse, error) {
	out := new(DeleteDatasetsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/DeleteDatasets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) ConfigConsolidation(ctx context.Context, in *ConfigConsolidationRequest, opts ...grpc.CallOption) (*ConfigConsolidationResponse, error) {
	out := new(ConfigConsolidationResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/ConfigConsolidation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) GetConsolidationParams(ctx context.Context, in *GetConsolidationParamsRequest, opts ...grpc.CallOption) (*GetConsolidationParamsResponse, error) {
	out := new(GetConsolidationParamsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/GetConsolidationParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) Consolidate(ctx context.Context, in *ConsolidateRequest, opts ...grpc.CallOption) (*ConsolidateResponse, error) {
	out := new(ConsolidateResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/Consolidate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) ListJobs(ctx context.Context, in *ListJobsRequest, opts ...grpc.CallOption) (*ListJobsResponse, error) {
	out := new(ListJobsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/ListJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error) {
	out := new(GetJobResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/GetJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) CleanJobs(ctx context.Context, in *CleanJobsRequest, opts ...grpc.CallOption) (*CleanJobsResponse, error) {
	out := new(CleanJobsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/CleanJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) RetryJob(ctx context.Context, in *RetryJobRequest, opts ...grpc.CallOption) (*RetryJobResponse, error) {
	out := new(RetryJobResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/RetryJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*CancelJobResponse, error) {
	out := new(CancelJobResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/CancelJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) ContinueJob(ctx context.Context, in *ContinueJobRequest, opts ...grpc.CallOption) (*ContinueJobResponse, error) {
	out := new(ContinueJobResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/ContinueJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) GetCube(ctx context.Context, in *GetCubeRequest, opts ...grpc.CallOption) (Geocube_GetCubeClient, error) {
	stream, err := c.cc.NewStream(ctx, &Geocube_ServiceDesc.Streams[3], "/geocube.Geocube/GetCube", opts...)
	if err != nil {
		return nil, err
	}
	x := &geocubeGetCubeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Geocube_GetCubeClient interface {
	Recv() (*GetCubeResponse, error)
	grpc.ClientStream
}

type geocubeGetCubeClient struct {
	grpc.ClientStream
}

func (x *geocubeGetCubeClient) Recv() (*GetCubeResponse, error) {
	m := new(GetCubeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geocubeClient) GetXYZTile(ctx context.Context, in *GetTileRequest, opts ...grpc.CallOption) (*GetTileResponse, error) {
	out := new(GetTileResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/GetXYZTile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) CreateLayout(ctx context.Context, in *CreateLayoutRequest, opts ...grpc.CallOption) (*CreateLayoutResponse, error) {
	out := new(CreateLayoutResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/CreateLayout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) DeleteLayout(ctx context.Context, in *DeleteLayoutRequest, opts ...grpc.CallOption) (*DeleteLayoutResponse, error) {
	out := new(DeleteLayoutResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/DeleteLayout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) ListLayouts(ctx context.Context, in *ListLayoutsRequest, opts ...grpc.CallOption) (*ListLayoutsResponse, error) {
	out := new(ListLayoutsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/ListLayouts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) FindContainerLayouts(ctx context.Context, in *FindContainerLayoutsRequest, opts ...grpc.CallOption) (Geocube_FindContainerLayoutsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Geocube_ServiceDesc.Streams[4], "/geocube.Geocube/FindContainerLayouts", opts...)
	if err != nil {
		return nil, err
	}
	x := &geocubeFindContainerLayoutsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Geocube_FindContainerLayoutsClient interface {
	Recv() (*FindContainerLayoutsResponse, error)
	grpc.ClientStream
}

type geocubeFindContainerLayoutsClient struct {
	grpc.ClientStream
}

func (x *geocubeFindContainerLayoutsClient) Recv() (*FindContainerLayoutsResponse, error) {
	m := new(FindContainerLayoutsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geocubeClient) TileAOI(ctx context.Context, in *TileAOIRequest, opts ...grpc.CallOption) (Geocube_TileAOIClient, error) {
	stream, err := c.cc.NewStream(ctx, &Geocube_ServiceDesc.Streams[5], "/geocube.Geocube/TileAOI", opts...)
	if err != nil {
		return nil, err
	}
	x := &geocubeTileAOIClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Geocube_TileAOIClient interface {
	Recv() (*TileAOIResponse, error)
	grpc.ClientStream
}

type geocubeTileAOIClient struct {
	grpc.ClientStream
}

func (x *geocubeTileAOIClient) Recv() (*TileAOIResponse, error) {
	m := new(TileAOIResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geocubeClient) CreateGrid(ctx context.Context, opts ...grpc.CallOption) (Geocube_CreateGridClient, error) {
	stream, err := c.cc.NewStream(ctx, &Geocube_ServiceDesc.Streams[6], "/geocube.Geocube/CreateGrid", opts...)
	if err != nil {
		return nil, err
	}
	x := &geocubeCreateGridClient{stream}
	return x, nil
}

type Geocube_CreateGridClient interface {
	Send(*CreateGridRequest) error
	CloseAndRecv() (*CreateGridResponse, error)
	grpc.ClientStream
}

type geocubeCreateGridClient struct {
	grpc.ClientStream
}

func (x *geocubeCreateGridClient) Send(m *CreateGridRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *geocubeCreateGridClient) CloseAndRecv() (*CreateGridResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CreateGridResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geocubeClient) DeleteGrid(ctx context.Context, in *DeleteGridRequest, opts ...grpc.CallOption) (*DeleteGridResponse, error) {
	out := new(DeleteGridResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/DeleteGrid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) ListGrids(ctx context.Context, in *ListGridsRequest, opts ...grpc.CallOption) (*ListGridsResponse, error) {
	out := new(ListGridsResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/ListGrids", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geocubeClient) Version(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error) {
	out := new(GetVersionResponse)
	err := c.cc.Invoke(ctx, "/geocube.Geocube/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeocubeServer is the server API for Geocube service.
// All implementations must embed UnimplementedGeocubeServer
// for forward compatibility
type GeocubeServer interface {
	// Create one or a list of records
	CreateRecords(context.Context, *CreateRecordsRequest) (*CreateRecordsResponse, error)
	// Get records from their ID
	GetRecords(*GetRecordsRequest, Geocube_GetRecordsServer) error
	// List records given criterias
	ListRecords(*ListRecordsRequest, Geocube_ListRecordsServer) error
	// Update records, adding or updating tags
	AddRecordsTags(context.Context, *AddRecordsTagsRequest) (*AddRecordsTagsResponse, error)
	// Update records, removing tags
	RemoveRecordsTags(context.Context, *RemoveRecordsTagsRequest) (*RemoveRecordsTagsResponse, error)
	// Delete records
	DeleteRecords(context.Context, *DeleteRecordsRequest) (*DeleteRecordsResponse, error)
	// Create an AOI if not exists or returns the aoi id of the aoi.
	CreateAOI(context.Context, *CreateAOIRequest) (*CreateAOIResponse, error)
	// Get an AOI from its ID
	GetAOI(context.Context, *GetAOIRequest) (*GetAOIResponse, error)
	// Create a variable
	CreateVariable(context.Context, *CreateVariableRequest) (*CreateVariableResponse, error)
	// Get a variable given its id, name or one of its instance id
	GetVariable(context.Context, *GetVariableRequest) (*GetVariableResponse, error)
	// Update some fields of a variable
	UpdateVariable(context.Context, *UpdateVariableRequest) (*UpdateVariableResponse, error)
	// Delete a variable iif no dataset has a reference on
	DeleteVariable(context.Context, *DeleteVariableRequest) (*DeleteVariableResponse, error)
	// List variables given a name pattern
	ListVariables(*ListVariablesRequest, Geocube_ListVariablesServer) error
	// Instantiate a variable
	InstantiateVariable(context.Context, *InstantiateVariableRequest) (*InstantiateVariableResponse, error)
	// Update metadata of an instance
	UpdateInstance(context.Context, *UpdateInstanceRequest) (*UpdateInstanceResponse, error)
	// Delete an instance iif no dataset has a reference on
	DeleteInstance(context.Context, *DeleteInstanceRequest) (*DeleteInstanceResponse, error)
	// Create or update a palette that can be used to create a display of a dataset
	CreatePalette(context.Context, *CreatePaletteRequest) (*CreatePaletteResponse, error)
	// GetInfo on containers
	GetContainers(context.Context, *GetContainersRequest) (*GetContainersResponse, error)
	// Index new datasets in the Geocube
	IndexDatasets(context.Context, *IndexDatasetsRequest) (*IndexDatasetsResponse, error)
	// Delete datasets using records, instances and/or filepath
	DeleteDatasets(context.Context, *DeleteDatasetsRequest) (*DeleteDatasetsResponse, error)
	// Configurate a consolidation process
	ConfigConsolidation(context.Context, *ConfigConsolidationRequest) (*ConfigConsolidationResponse, error)
	// Get the configuration of a consolidation
	GetConsolidationParams(context.Context, *GetConsolidationParamsRequest) (*GetConsolidationParamsResponse, error)
	// Start a consolidation job
	Consolidate(context.Context, *ConsolidateRequest) (*ConsolidateResponse, error)
	// List the jobs given a name pattern
	ListJobs(context.Context, *ListJobsRequest) (*ListJobsResponse, error)
	// Get a job given its name
	GetJob(context.Context, *GetJobRequest) (*GetJobResponse, error)
	// Delete jobs given their status
	CleanJobs(context.Context, *CleanJobsRequest) (*CleanJobsResponse, error)
	// Retry a job
	RetryJob(context.Context, *RetryJobRequest) (*RetryJobResponse, error)
	// Cancel a job
	CancelJob(context.Context, *CancelJobRequest) (*CancelJobResponse, error)
	// Continue a job that is in waiting state
	ContinueJob(context.Context, *ContinueJobRequest) (*ContinueJobResponse, error)
	// Get a cube of data given a CubeParams
	GetCube(*GetCubeRequest, Geocube_GetCubeServer) error
	// Get a XYZTile (can be used with a TileServer, provided a GRPCGateway is up)
	GetXYZTile(context.Context, *GetTileRequest) (*GetTileResponse, error)
	// Create a layout to be used for tiling or consolidation
	CreateLayout(context.Context, *CreateLayoutRequest) (*CreateLayoutResponse, error)
	// Delete a layout given its name
	DeleteLayout(context.Context, *DeleteLayoutRequest) (*DeleteLayoutResponse, error)
	// List layouts given a name pattern
	ListLayouts(context.Context, *ListLayoutsRequest) (*ListLayoutsResponse, error)
	// Find all the layouts known for a set of containers
	FindContainerLayouts(*FindContainerLayoutsRequest, Geocube_FindContainerLayoutsServer) error
	// Tile an AOI given a layout
	TileAOI(*TileAOIRequest, Geocube_TileAOIServer) error
	// Create a grid that can be used to tile an AOI
	CreateGrid(Geocube_CreateGridServer) error
	// Delete a grid
	DeleteGrid(context.Context, *DeleteGridRequest) (*DeleteGridResponse, error)
	// List grids given a name pattern
	ListGrids(context.Context, *ListGridsRequest) (*ListGridsResponse, error)
	// Version of the GeocubeServer
	Version(context.Context, *GetVersionRequest) (*GetVersionResponse, error)
	mustEmbedUnimplementedGeocubeServer()
}

// UnimplementedGeocubeServer must be embedded to have forward compatible implementations.
type UnimplementedGeocubeServer struct {
}

func (UnimplementedGeocubeServer) CreateRecords(context.Context, *CreateRecordsRequest) (*CreateRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRecords not implemented")
}
func (UnimplementedGeocubeServer) GetRecords(*GetRecordsRequest, Geocube_GetRecordsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRecords not implemented")
}
func (UnimplementedGeocubeServer) ListRecords(*ListRecordsRequest, Geocube_ListRecordsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListRecords not implemented")
}
func (UnimplementedGeocubeServer) AddRecordsTags(context.Context, *AddRecordsTagsRequest) (*AddRecordsTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRecordsTags not implemented")
}
func (UnimplementedGeocubeServer) RemoveRecordsTags(context.Context, *RemoveRecordsTagsRequest) (*RemoveRecordsTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRecordsTags not implemented")
}
func (UnimplementedGeocubeServer) DeleteRecords(context.Context, *DeleteRecordsRequest) (*DeleteRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRecords not implemented")
}
func (UnimplementedGeocubeServer) CreateAOI(context.Context, *CreateAOIRequest) (*CreateAOIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAOI not implemented")
}
func (UnimplementedGeocubeServer) GetAOI(context.Context, *GetAOIRequest) (*GetAOIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAOI not implemented")
}
func (UnimplementedGeocubeServer) CreateVariable(context.Context, *CreateVariableRequest) (*CreateVariableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVariable not implemented")
}
func (UnimplementedGeocubeServer) GetVariable(context.Context, *GetVariableRequest) (*GetVariableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVariable not implemented")
}
func (UnimplementedGeocubeServer) UpdateVariable(context.Context, *UpdateVariableRequest) (*UpdateVariableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVariable not implemented")
}
func (UnimplementedGeocubeServer) DeleteVariable(context.Context, *DeleteVariableRequest) (*DeleteVariableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVariable not implemented")
}
func (UnimplementedGeocubeServer) ListVariables(*ListVariablesRequest, Geocube_ListVariablesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListVariables not implemented")
}
func (UnimplementedGeocubeServer) InstantiateVariable(context.Context, *InstantiateVariableRequest) (*InstantiateVariableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantiateVariable not implemented")
}
func (UnimplementedGeocubeServer) UpdateInstance(context.Context, *UpdateInstanceRequest) (*UpdateInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInstance not implemented")
}
func (UnimplementedGeocubeServer) DeleteInstance(context.Context, *DeleteInstanceRequest) (*DeleteInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInstance not implemented")
}
func (UnimplementedGeocubeServer) CreatePalette(context.Context, *CreatePaletteRequest) (*CreatePaletteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePalette not implemented")
}
func (UnimplementedGeocubeServer) GetContainers(context.Context, *GetContainersRequest) (*GetContainersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContainers not implemented")
}
func (UnimplementedGeocubeServer) IndexDatasets(context.Context, *IndexDatasetsRequest) (*IndexDatasetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IndexDatasets not implemented")
}
func (UnimplementedGeocubeServer) DeleteDatasets(context.Context, *DeleteDatasetsRequest) (*DeleteDatasetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDatasets not implemented")
}
func (UnimplementedGeocubeServer) ConfigConsolidation(context.Context, *ConfigConsolidationRequest) (*ConfigConsolidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigConsolidation not implemented")
}
func (UnimplementedGeocubeServer) GetConsolidationParams(context.Context, *GetConsolidationParamsRequest) (*GetConsolidationParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsolidationParams not implemented")
}
func (UnimplementedGeocubeServer) Consolidate(context.Context, *ConsolidateRequest) (*ConsolidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Consolidate not implemented")
}
func (UnimplementedGeocubeServer) ListJobs(context.Context, *ListJobsRequest) (*ListJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}
func (UnimplementedGeocubeServer) GetJob(context.Context, *GetJobRequest) (*GetJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedGeocubeServer) CleanJobs(context.Context, *CleanJobsRequest) (*CleanJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanJobs not implemented")
}
func (UnimplementedGeocubeServer) RetryJob(context.Context, *RetryJobRequest) (*RetryJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetryJob not implemented")
}
func (UnimplementedGeocubeServer) CancelJob(context.Context, *CancelJobRequest) (*CancelJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJob not implemented")
}
func (UnimplementedGeocubeServer) ContinueJob(context.Context, *ContinueJobRequest) (*ContinueJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContinueJob not implemented")
}
func (UnimplementedGeocubeServer) GetCube(*GetCubeRequest, Geocube_GetCubeServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCube not implemented")
}
func (UnimplementedGeocubeServer) GetXYZTile(context.Context, *GetTileRequest) (*GetTileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetXYZTile not implemented")
}
func (UnimplementedGeocubeServer) CreateLayout(context.Context, *CreateLayoutRequest) (*CreateLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLayout not implemented")
}
func (UnimplementedGeocubeServer) DeleteLayout(context.Context, *DeleteLayoutRequest) (*DeleteLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLayout not implemented")
}
func (UnimplementedGeocubeServer) ListLayouts(context.Context, *ListLayoutsRequest) (*ListLayoutsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLayouts not implemented")
}
func (UnimplementedGeocubeServer) FindContainerLayouts(*FindContainerLayoutsRequest, Geocube_FindContainerLayoutsServer) error {
	return status.Errorf(codes.Unimplemented, "method FindContainerLayouts not implemented")
}
func (UnimplementedGeocubeServer) TileAOI(*TileAOIRequest, Geocube_TileAOIServer) error {
	return status.Errorf(codes.Unimplemented, "method TileAOI not implemented")
}
func (UnimplementedGeocubeServer) CreateGrid(Geocube_CreateGridServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateGrid not implemented")
}
func (UnimplementedGeocubeServer) DeleteGrid(context.Context, *DeleteGridRequest) (*DeleteGridResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGrid not implemented")
}
func (UnimplementedGeocubeServer) ListGrids(context.Context, *ListGridsRequest) (*ListGridsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGrids not implemented")
}
func (UnimplementedGeocubeServer) Version(context.Context, *GetVersionRequest) (*GetVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedGeocubeServer) mustEmbedUnimplementedGeocubeServer() {}

// UnsafeGeocubeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeocubeServer will
// result in compilation errors.
type UnsafeGeocubeServer interface {
	mustEmbedUnimplementedGeocubeServer()
}

func RegisterGeocubeServer(s grpc.ServiceRegistrar, srv GeocubeServer) {
	s.RegisterService(&Geocube_ServiceDesc, srv)
}

func _Geocube_CreateRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).CreateRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/CreateRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).CreateRecords(ctx, req.(*CreateRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_GetRecords_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRecordsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeocubeServer).GetRecords(m, &geocubeGetRecordsServer{stream})
}

type Geocube_GetRecordsServer interface {
	Send(*GetRecordsResponseItem) error
	grpc.ServerStream
}

type geocubeGetRecordsServer struct {
	grpc.ServerStream
}

func (x *geocubeGetRecordsServer) Send(m *GetRecordsResponseItem) error {
	return x.ServerStream.SendMsg(m)
}

func _Geocube_ListRecords_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListRecordsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeocubeServer).ListRecords(m, &geocubeListRecordsServer{stream})
}

type Geocube_ListRecordsServer interface {
	Send(*ListRecordsResponseItem) error
	grpc.ServerStream
}

type geocubeListRecordsServer struct {
	grpc.ServerStream
}

func (x *geocubeListRecordsServer) Send(m *ListRecordsResponseItem) error {
	return x.ServerStream.SendMsg(m)
}

func _Geocube_AddRecordsTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRecordsTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).AddRecordsTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/AddRecordsTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).AddRecordsTags(ctx, req.(*AddRecordsTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_RemoveRecordsTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRecordsTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).RemoveRecordsTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/RemoveRecordsTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).RemoveRecordsTags(ctx, req.(*RemoveRecordsTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_DeleteRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).DeleteRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/DeleteRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).DeleteRecords(ctx, req.(*DeleteRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_CreateAOI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAOIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).CreateAOI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/CreateAOI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).CreateAOI(ctx, req.(*CreateAOIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_GetAOI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAOIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).GetAOI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/GetAOI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).GetAOI(ctx, req.(*GetAOIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_CreateVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVariableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).CreateVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/CreateVariable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).CreateVariable(ctx, req.(*CreateVariableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_GetVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVariableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).GetVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/GetVariable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).GetVariable(ctx, req.(*GetVariableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_UpdateVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVariableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).UpdateVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/UpdateVariable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).UpdateVariable(ctx, req.(*UpdateVariableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_DeleteVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVariableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).DeleteVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/DeleteVariable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).DeleteVariable(ctx, req.(*DeleteVariableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_ListVariables_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListVariablesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeocubeServer).ListVariables(m, &geocubeListVariablesServer{stream})
}

type Geocube_ListVariablesServer interface {
	Send(*ListVariablesResponseItem) error
	grpc.ServerStream
}

type geocubeListVariablesServer struct {
	grpc.ServerStream
}

func (x *geocubeListVariablesServer) Send(m *ListVariablesResponseItem) error {
	return x.ServerStream.SendMsg(m)
}

func _Geocube_InstantiateVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstantiateVariableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).InstantiateVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/InstantiateVariable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).InstantiateVariable(ctx, req.(*InstantiateVariableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_UpdateInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).UpdateInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/UpdateInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).UpdateInstance(ctx, req.(*UpdateInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_DeleteInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).DeleteInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/DeleteInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).DeleteInstance(ctx, req.(*DeleteInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_CreatePalette_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePaletteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).CreatePalette(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/CreatePalette",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).CreatePalette(ctx, req.(*CreatePaletteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_GetContainers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContainersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).GetContainers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/GetContainers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).GetContainers(ctx, req.(*GetContainersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_IndexDatasets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexDatasetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).IndexDatasets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/IndexDatasets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).IndexDatasets(ctx, req.(*IndexDatasetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_DeleteDatasets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDatasetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).DeleteDatasets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/DeleteDatasets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).DeleteDatasets(ctx, req.(*DeleteDatasetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_ConfigConsolidation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigConsolidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).ConfigConsolidation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/ConfigConsolidation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).ConfigConsolidation(ctx, req.(*ConfigConsolidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_GetConsolidationParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsolidationParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).GetConsolidationParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/GetConsolidationParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).GetConsolidationParams(ctx, req.(*GetConsolidationParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_Consolidate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsolidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).Consolidate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/Consolidate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).Consolidate(ctx, req.(*ConsolidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/ListJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).ListJobs(ctx, req.(*ListJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).GetJob(ctx, req.(*GetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_CleanJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).CleanJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/CleanJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).CleanJobs(ctx, req.(*CleanJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_RetryJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetryJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).RetryJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/RetryJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).RetryJob(ctx, req.(*RetryJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/CancelJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).CancelJob(ctx, req.(*CancelJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_ContinueJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContinueJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).ContinueJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/ContinueJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).ContinueJob(ctx, req.(*ContinueJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_GetCube_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetCubeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeocubeServer).GetCube(m, &geocubeGetCubeServer{stream})
}

type Geocube_GetCubeServer interface {
	Send(*GetCubeResponse) error
	grpc.ServerStream
}

type geocubeGetCubeServer struct {
	grpc.ServerStream
}

func (x *geocubeGetCubeServer) Send(m *GetCubeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Geocube_GetXYZTile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).GetXYZTile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/GetXYZTile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).GetXYZTile(ctx, req.(*GetTileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_CreateLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).CreateLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/CreateLayout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).CreateLayout(ctx, req.(*CreateLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_DeleteLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).DeleteLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/DeleteLayout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).DeleteLayout(ctx, req.(*DeleteLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_ListLayouts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLayoutsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).ListLayouts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/ListLayouts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).ListLayouts(ctx, req.(*ListLayoutsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_FindContainerLayouts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FindContainerLayoutsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeocubeServer).FindContainerLayouts(m, &geocubeFindContainerLayoutsServer{stream})
}

type Geocube_FindContainerLayoutsServer interface {
	Send(*FindContainerLayoutsResponse) error
	grpc.ServerStream
}

type geocubeFindContainerLayoutsServer struct {
	grpc.ServerStream
}

func (x *geocubeFindContainerLayoutsServer) Send(m *FindContainerLayoutsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Geocube_TileAOI_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TileAOIRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeocubeServer).TileAOI(m, &geocubeTileAOIServer{stream})
}

type Geocube_TileAOIServer interface {
	Send(*TileAOIResponse) error
	grpc.ServerStream
}

type geocubeTileAOIServer struct {
	grpc.ServerStream
}

func (x *geocubeTileAOIServer) Send(m *TileAOIResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Geocube_CreateGrid_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GeocubeServer).CreateGrid(&geocubeCreateGridServer{stream})
}

type Geocube_CreateGridServer interface {
	SendAndClose(*CreateGridResponse) error
	Recv() (*CreateGridRequest, error)
	grpc.ServerStream
}

type geocubeCreateGridServer struct {
	grpc.ServerStream
}

func (x *geocubeCreateGridServer) SendAndClose(m *CreateGridResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *geocubeCreateGridServer) Recv() (*CreateGridRequest, error) {
	m := new(CreateGridRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Geocube_DeleteGrid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGridRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).DeleteGrid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/DeleteGrid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).DeleteGrid(ctx, req.(*DeleteGridRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_ListGrids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGridsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).ListGrids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/ListGrids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).ListGrids(ctx, req.(*ListGridsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geocube_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeocubeServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geocube.Geocube/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeocubeServer).Version(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Geocube_ServiceDesc is the grpc.ServiceDesc for Geocube service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Geocube_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "geocube.Geocube",
	HandlerType: (*GeocubeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRecords",
			Handler:    _Geocube_CreateRecords_Handler,
		},
		{
			MethodName: "AddRecordsTags",
			Handler:    _Geocube_AddRecordsTags_Handler,
		},
		{
			MethodName: "RemoveRecordsTags",
			Handler:    _Geocube_RemoveRecordsTags_Handler,
		},
		{
			MethodName: "DeleteRecords",
			Handler:    _Geocube_DeleteRecords_Handler,
		},
		{
			MethodName: "CreateAOI",
			Handler:    _Geocube_CreateAOI_Handler,
		},
		{
			MethodName: "GetAOI",
			Handler:    _Geocube_GetAOI_Handler,
		},
		{
			MethodName: "CreateVariable",
			Handler:    _Geocube_CreateVariable_Handler,
		},
		{
			MethodName: "GetVariable",
			Handler:    _Geocube_GetVariable_Handler,
		},
		{
			MethodName: "UpdateVariable",
			Handler:    _Geocube_UpdateVariable_Handler,
		},
		{
			MethodName: "DeleteVariable",
			Handler:    _Geocube_DeleteVariable_Handler,
		},
		{
			MethodName: "InstantiateVariable",
			Handler:    _Geocube_InstantiateVariable_Handler,
		},
		{
			MethodName: "UpdateInstance",
			Handler:    _Geocube_UpdateInstance_Handler,
		},
		{
			MethodName: "DeleteInstance",
			Handler:    _Geocube_DeleteInstance_Handler,
		},
		{
			MethodName: "CreatePalette",
			Handler:    _Geocube_CreatePalette_Handler,
		},
		{
			MethodName: "GetContainers",
			Handler:    _Geocube_GetContainers_Handler,
		},
		{
			MethodName: "IndexDatasets",
			Handler:    _Geocube_IndexDatasets_Handler,
		},
		{
			MethodName: "DeleteDatasets",
			Handler:    _Geocube_DeleteDatasets_Handler,
		},
		{
			MethodName: "ConfigConsolidation",
			Handler:    _Geocube_ConfigConsolidation_Handler,
		},
		{
			MethodName: "GetConsolidationParams",
			Handler:    _Geocube_GetConsolidationParams_Handler,
		},
		{
			MethodName: "Consolidate",
			Handler:    _Geocube_Consolidate_Handler,
		},
		{
			MethodName: "ListJobs",
			Handler:    _Geocube_ListJobs_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _Geocube_GetJob_Handler,
		},
		{
			MethodName: "CleanJobs",
			Handler:    _Geocube_CleanJobs_Handler,
		},
		{
			MethodName: "RetryJob",
			Handler:    _Geocube_RetryJob_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _Geocube_CancelJob_Handler,
		},
		{
			MethodName: "ContinueJob",
			Handler:    _Geocube_ContinueJob_Handler,
		},
		{
			MethodName: "GetXYZTile",
			Handler:    _Geocube_GetXYZTile_Handler,
		},
		{
			MethodName: "CreateLayout",
			Handler:    _Geocube_CreateLayout_Handler,
		},
		{
			MethodName: "DeleteLayout",
			Handler:    _Geocube_DeleteLayout_Handler,
		},
		{
			MethodName: "ListLayouts",
			Handler:    _Geocube_ListLayouts_Handler,
		},
		{
			MethodName: "DeleteGrid",
			Handler:    _Geocube_DeleteGrid_Handler,
		},
		{
			MethodName: "ListGrids",
			Handler:    _Geocube_ListGrids_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _Geocube_Version_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetRecords",
			Handler:       _Geocube_GetRecords_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListRecords",
			Handler:       _Geocube_ListRecords_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListVariables",
			Handler:       _Geocube_ListVariables_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCube",
			Handler:       _Geocube_GetCube_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FindContainerLayouts",
			Handler:       _Geocube_FindContainerLayouts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TileAOI",
			Handler:       _Geocube_TileAOI_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateGrid",
			Handler:       _Geocube_CreateGrid_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pb/geocube.proto",
}
